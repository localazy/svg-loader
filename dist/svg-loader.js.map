{"version":3,"file":"svg-loader.js","mappings":"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;;;;;;;ACtBa;;AAEb,QAAQ,UAAU,EAAE,4GAA+B;AACnD,iBAAiB,mBAAO,CAAC,2CAAiB;AAC1C,oBAAoB,mBAAO,CAAC,mDAAqB;AACjD,gBAAgB,mBAAO,CAAC,uCAAe;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2CAA2C,IAAI;;AAE/C;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN,4BAA4B,IAAI;AAChC;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU,gDAAgD;;AAE1D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,eAAe;;AAEjE;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,GAAG,GAAG,eAAe;AAC5C;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,4BAA4B;AAChD,cAAc,cAAc;;AAE5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,kBAAkB,gCAAgC;AAClD,YAAY,cAAc;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,IAAI,aAAa,iBAAiB,GAAG,oBAAoB;AACrF;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,mCAAmC,IAAI;AACvC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,GAAG;AACH","sources":["webpack://@localazy/svg-loader/./lib/counter.js","webpack://@localazy/svg-loader/./lib/css-url-fixer.js","webpack://@localazy/svg-loader/./lib/scope-css.js","webpack://@localazy/svg-loader/./node_modules/@sifrr/storage/dist/sifrr.storage.min.js","webpack://@localazy/svg-loader/webpack/bootstrap","webpack://@localazy/svg-loader/./svg-loader.js"],"sourcesContent":["\"use strict\";\n\nlet counter = 0;\n\nmodule.exports = {\n    incr () {\n        return ++counter;\n    },\n\n    decr () {\n        return --counter;\n    },\n\n    curr () {\n        return counter;\n    }\n};","\"use strict\";\n\n/**\n * Handle all SVG references correctly, which can be\n *   a) via attributes: url(#abc)\n *   b) via tags: <use href=\"#abc\" />\n *   c) via css: .class { fill: url(#abc) }\n * @param {object} idMap: Map previous id with the new unique id\n * @param {string} attributeValueOrCSS\n * @param {string} attributeName\n * @returns attribute or css value with correct id\n */\nmodule.exports = (idMap, attributeValueOrCSS, attributeName = \"\") => {\n    const svgRefRegex = /url\\(['\"]?#([\\w:.-]+)['\"]?\\)/g;\n    const urlRefRegex = /#([\\w:.-]+)/g;\n\n    // fill=\"url(#abc)\" -> fill=\"url(#abc_2)\"\n    // Use the unique IDs created previously\n    if (attributeValueOrCSS.match(svgRefRegex)) {\n        attributeValueOrCSS = attributeValueOrCSS.replace(svgRefRegex, function (g0, g1) {\n            if (!idMap[g1]) {\n                return g0;\n            }\n            return `url(#${idMap[g1]})`;\n        });\n    }\n\n    // <use href=\"#X\" -> <use href=\"#X_23\"\n    // Use the unique IDs created previously\n    if ([\"href\", \"xlink:href\"].includes(attributeName)) {\n        if (attributeValueOrCSS.match(urlRefRegex)) {\n            attributeValueOrCSS = attributeValueOrCSS.replace(urlRefRegex, function (g0, g1) {\n                if (!idMap[g1]) {\n                    return g0;\n                }\n                return `#${idMap[g1]}`;\n            });\n        }\n    }\n    return attributeValueOrCSS;\n};\n","\"use strict\";\n\n// Source: https://github.com/thomaspark/scoper\nmodule.exports = (css, prefix, idMap) => {\n    const re = new RegExp(\"([^\\r\\n,{}]+)(,(?=[^}]*{)|\\s*{)\", \"g\");\n    css = css.replace(re, function (g0, g1, g2) {\n\n        if (g1.match(/^\\s*(@media|@.*keyframes|to|from|@font-face|1?[0-9]?[0-9])/)) {\n            return g1 + g2;\n        }\n\n        const idRegex = /#(\\w+)/;\n        const match = g1.match(idRegex);\n\n        if (match && idMap[match[1]]) {\n            g1 = g1.replace(match[0], `#${idMap[match[1]]}`);\n        }\n\n        g1 = g1.replace(/^(\\s*)/, \"$1\" + prefix + \" \");\n\n        return g1 + g2;\n    });\n\n    return css;\n};","/*! Sifrr.Storage v0.0.9 - sifrr project | MIT licensed | https://github.com/sifrr/sifrr */\nthis.Sifrr=this.Sifrr||{},this.Sifrr.Storage=function(t){\"use strict\";var e=Object.prototype.toString,r=\"~SS%l3g5k3~\";function s(t){var e=t;if(\"string\"==typeof t)try{e=t=JSON.parse(t)}catch(t){// do nothing\n}if(\"string\"==typeof t&&t.indexOf(r)>0){var[n,i,a]=t.split(r);e=\"ArrayBuffer\"===n?new Uint8Array(i.split(\",\").map(t=>parseInt(t))).buffer:\"Blob\"===n?function(t,e){return new Blob([new Uint8Array(t.split(\",\")).buffer],{type:e})}(a,i):new window[n](i.split(\",\"))}else if(Array.isArray(t))e=[],t.forEach((t,r)=>{e[r]=s(t)});else if(\"object\"==typeof t){if(null===t)return null;for(var o in e={},t)e[o]=s(t[o])}return e}function n(t){if(\"object\"!=typeof t)return JSON.stringify(t);if(null===t)return\"null\";if(Array.isArray(t))return JSON.stringify(t.map(t=>n(t)));var s=e.call(t).slice(8,-1);if(\"Object\"===s){var i={};for(var a in t)i[a]=n(t[a]);return JSON.stringify(i)}return\"ArrayBuffer\"===s?t=new Uint8Array(t):\"Blob\"===s&&(t=t.type+r+function(t){var e=URL.createObjectURL(t),r=new XMLHttpRequest;r.open(\"GET\",e,!1),r.send(),URL.revokeObjectURL(e);for(var s=new Uint8Array(r.response.length),n=0;n<r.response.length;++n)s[n]=r.response.charCodeAt(n);return s.toString()}(t)),s+r+t.toString()}\n// always bind to storage\nvar i=(t,e)=>{var r=Date.now();return Object.keys(t).forEach(s=>{if(void 0!==t[s]){var{createdAt:n,ttl:i}=t[s];t[s]=t[s]&&t[s].value,0!==i&&r-n>i&&(delete t[s],e&&e(s))}}),t},a=(t,e)=>t&&t.value?(t.ttl=t.ttl||e,t.createdAt=Date.now(),t):{value:t,ttl:e,createdAt:Date.now()},o=(t,e,r)=>{if(\"string\"==typeof t)return{[t]:a(e,r)};var s={};return Object.keys(t).forEach(e=>s[e]=a(t[e],r)),s},c=t=>Array.isArray(t)?t:[t],l={name:\"SifrrStorage\",version:1,description:\"Sifrr Storage\",size:5242880,ttl:0};class u{constructor(t=l){this.type=this.constructor.type,this.table={},Object.assign(this,l,t),this.tableName=this.name+this.version}// overwrited methods\nselect(t){var e=this.getStore(),r={};return t.forEach(t=>r[t]=e[t]),r}upsert(t){var e=this.getStore();for(var r in t)e[r]=t[r];return this.setStore(e),!0}delete(t){var e=this.getStore();return t.forEach(t=>delete e[t]),this.setStore(e),!0}deleteAll(){return this.setStore({}),!0}getStore(){return this.table}setStore(t){this.table=t}keys(){return Promise.resolve(this.getStore()).then(t=>Object.keys(t))}all(){return Promise.resolve(this.getStore()).then(t=>i(t,this.del.bind(this)))}get(t){return Promise.resolve(this.select(c(t))).then(t=>i(t,this.del.bind(this)))}set(t,e){return Promise.resolve(this.upsert(o(t,e,this.ttl)))}del(t){return Promise.resolve(this.delete(c(t)))}clear(){return Promise.resolve(this.deleteAll())}memoize(t,e=((...t)=>\"string\"==typeof t[0]?t[0]:n(t[0]))){return(...r)=>{var s=e(...r);return this.get(s).then(e=>{if(void 0===e[s]||null===e[s]){var n=t(...r);if(!(n instanceof Promise))throw Error(\"Only promise returning functions can be memoized\");return n.then(t=>this.set(s,t).then(()=>t))}return e[s]})}}isSupported(t=!0){return!(!t||\"undefined\"!=typeof window&&\"undefined\"!=typeof document)||!(!window||!this.hasStore())}hasStore(){return!0}isEqual(t){return this.tableName==t.tableName&&this.type==t.type}// aliases\nstatic stringify(t){return n(t)}static parse(t){return s(t)}static _add(t){this._all=this._all||[],this._all.push(t)}static _matchingInstance(t){for(var e=this._all||[],r=e.length,s=0;s<r;s++)if(e[s].isEqual(t))return e[s];return this._add(t),t}}class h extends u{constructor(t){return super(t),this.constructor._matchingInstance(this)}select(t){var e={},r=[];return t.forEach(t=>r.push(this._tx(\"readonly\",\"get\",t,void 0).then(r=>e[t]=r))),Promise.all(r).then(()=>e)}upsert(t){var e=[];for(var r in t)e.push(this._tx(\"readwrite\",\"put\",t[r],r));return Promise.all(e).then(()=>!0)}delete(t){var e=[];return t.forEach(t=>e.push(this._tx(\"readwrite\",\"delete\",t,void 0))),Promise.all(e).then(()=>!0)}deleteAll(){return this._tx(\"readwrite\",\"clear\",void 0,void 0)}_tx(t,e,r,s){var n=this;return this.store=this.store||this.createStore(n.tableName),this.store.then(i=>new Promise((a,o)=>{var c=i.transaction(n.tableName,t).objectStore(n.tableName),l=c[e].call(c,r,s);l.onsuccess=t=>a(t.target.result),l.onerror=t=>o(t.error)}))}getStore(){return this._tx(\"readonly\",\"getAllKeys\",void 0,void 0).then(this.select.bind(this))}createStore(t){return new Promise((e,r)=>{var s=window.indexedDB.open(t,1);s.onupgradeneeded=()=>{s.result.createObjectStore(t)},s.onsuccess=()=>e(s.result),s.onerror=()=>r(s.error)})}hasStore(){return!!window.indexedDB}static get type(){return\"indexeddb\"}}class p extends u{constructor(t){return super(t),this.constructor._matchingInstance(this)}parsedData(){}select(t){var e=t.map(()=>\"?\").join(\", \");// Need to give array for ? values in executeSql's 2nd argument\nreturn this.execSql(\"SELECT key, value FROM \".concat(this.tableName,\" WHERE key in (\").concat(e,\")\"),t)}upsert(t){return this.getWebsql().transaction(e=>{for(var r in t)e.executeSql(\"INSERT OR REPLACE INTO \".concat(this.tableName,\"(key, value) VALUES (?, ?)\"),[r,this.constructor.stringify(t[r])])}),!0}delete(t){var e=t.map(()=>\"?\").join(\", \");return this.execSql(\"DELETE FROM \".concat(this.tableName,\" WHERE key in (\").concat(e,\")\"),t),!0}deleteAll(){return this.execSql(\"DELETE FROM \".concat(this.tableName)),!0}getStore(){return this.execSql(\"SELECT key, value FROM \".concat(this.tableName))}hasStore(){return!!window.openDatabase}getWebsql(){return this._store?this._store:(this._store=window.openDatabase(\"ss\",1,this.description,this.size),this.execSql(\"CREATE TABLE IF NOT EXISTS \".concat(this.tableName,\" (key unique, value)\")),this._store)}execSql(t,e=[]){var r=this;return new Promise(s=>{r.getWebsql().transaction((function(n){n.executeSql(t,e,(t,e)=>{s(r.parseResults(e))})}))})}parseResults(t){for(var e={},r=t.rows.length,s=0;s<r;s++)e[t.rows.item(s).key]=this.constructor.parse(t.rows.item(s).value);return e}static get type(){return\"websql\"}}class d extends u{constructor(t){return super(t),this.constructor._matchingInstance(this)}select(t){var e={};return t.forEach(t=>{var r=this.constructor.parse(this.getLocalStorage().getItem(this.tableName+\"/\"+t));null!==r&&(e[t]=r)}),e}upsert(t){for(var e in t)this.getLocalStorage().setItem(this.tableName+\"/\"+e,this.constructor.stringify(t[e]));return!0}delete(t){return t.map(t=>this.getLocalStorage().removeItem(this.tableName+\"/\"+t)),!0}deleteAll(){return Object.keys(this.getLocalStorage()).forEach(t=>{0===t.indexOf(this.tableName)&&this.getLocalStorage().removeItem(t)}),!0}getStore(){return this.select(Object.keys(this.getLocalStorage()).map(t=>{if(0===t.indexOf(this.tableName))return t.slice(this.tableName.length+1)}).filter(t=>void 0!==t))}getLocalStorage(){return window.localStorage}hasStore(){return!!window.localStorage}static get type(){return\"localstorage\"}}var f=new Date(0).toUTCString(),g=\"%3D\",S=new RegExp(g,\"g\");class v extends u{constructor(t){return super(t),this.constructor._matchingInstance(this)}upsert(t){for(var e in t)this.setStore(\"\".concat(this.tableName,\"/\").concat(e,\"=\").concat(this.constructor.stringify(t[e]).replace(/=/g,g),\"; path=/\"));return!0}delete(t){return t.forEach(t=>this.setStore(\"\".concat(this.tableName,\"/\").concat(t,\"=; expires=\").concat(f,\"; path=/\"))),!0}deleteAll(){return this.keys().then(this.delete.bind(this))}getStore(){var t=document.cookie,e={};return t.split(\"; \").forEach(t=>{var[r,s]=t.split(\"=\");0===r.indexOf(this.tableName)&&(e[r.slice(this.tableName.length+1)]=this.constructor.parse(s.replace(S,\"=\")))}),e}setStore(t){document.cookie=t}hasStore(){return void 0!==document.cookie}static get type(){return\"cookies\"}}class y extends u{constructor(t){return super(t),this.constructor._matchingInstance(this)}hasStore(){return!0}static get type(){return\"jsonstorage\"}}var m={[h.type]:h,[p.type]:p,[d.type]:d,[v.type]:v,[y.type]:y};return t.Cookies=v,t.IndexedDB=h,t.JsonStorage=y,t.LocalStorage=d,t.WebSQL=p,t.availableStores=m,t.getStorage=function(t){return function(t=[],e={}){t=t.concat([h.type,p.type,d.type,v.type,y.type]);for(var r=0;r<t.length;r++){var s=m[t[r]];if(s){var n=new s(e);if(n.isSupported())return n}}throw Error(\"No compatible storage found. Available types: \"+Object.keys(m).join(\", \")+\".\")}(\"string\"==typeof t?[t]:(t||{}).priority,\"string\"==typeof t?{}:t)},t.default&&(t=t.default),t}({});\n/*! (c) @aadityataparia */\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\n\nconst { Storage } = require(\"@sifrr/storage\").Sifrr;\nconst cssScope = require(\"./lib/scope-css\");\nconst cssUrlFixer = require(\"./lib/css-url-fixer\");\nconst counter = require(\"./lib/counter\");\n\nlet options = {\n  priority: [\"indexeddb\", \"websql\", \"localstorage\", \"jsonstorage\"], // Priority Array of type of storages to use\n  name: \"svg-loader-cache\", // name of table (treat this as a variable name, i.e. no Spaces or special characters allowed)\n  version: 1, // version number (integer / float / string), 1 is treated same as '1'\n  desciption: \"SVG Loader Cache\", // description (text)\n  size: 5 * 1024 * 1024, // Max db size in bytes only for websql (integer)\n  ttl: 0, // Time to live/expire for data in table (in ms), 0 = forever, data will expire ttl ms after saving\n};\n\nconst storage = Storage.getStorage(options);\n\nconst isCacheAvailable = async (url) => {\n  try {\n    let item = await storage.get(`loader_${url}`);\n\n    if (!item) {\n      return;\n    }\n\n    item = JSON.parse(item);\n\n    if (Date.now() < item.expiry) {\n      return item.data;\n    } else {\n      storage.del(`loader_${url}`);\n      return;\n    }\n  } catch (e) {\n    return;\n  }\n};\n\nconst setCache = async (url, data, cacheOpt) => {\n  try {\n    const cacheExp = parseInt(cacheOpt, 10);\n\n    await storage.set(\n      `loader_${url}`,\n      JSON.stringify({\n        data,\n        expiry:\n          Date.now() +\n          (Number.isNaN(cacheExp) ? 60 * 60 * 1000 * 24 : cacheExp),\n      })\n    );\n  } catch (e) {\n    console.error(e);\n  }\n};\n\nconst DOM_EVENTS = [];\nconst getAllEventNames = () => {\n  if (DOM_EVENTS.length) {\n    return DOM_EVENTS;\n  }\n\n  for (const prop in document.head) {\n    if (prop.startsWith(\"on\")) {\n      DOM_EVENTS.push(prop);\n    }\n  }\n\n  return DOM_EVENTS;\n};\n\nconst attributesSet = {};\nconst renderBody = (elem, options, body) => {\n  const { enableJs, disableUniqueIds, disableCssScoping } = options;\n\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(body, \"text/html\");\n  const fragment = doc.querySelector(\"svg\");\n\n  const eventNames = getAllEventNames();\n\n  // When svg-loader is loading in the same element, it's\n  // important to keep track of original properties.\n  const elemAttributesSet =\n    attributesSet[elem.getAttribute(\"data-id\")] || new Set();\n\n  const elemUniqueId =\n    elem.getAttribute(\"data-id\") || `svg-loader_${counter.incr()}`;\n\n  const idMap = {};\n\n  if (!disableUniqueIds) {\n    // Append a unique suffix for every ID so elements don't conflict.\n    Array.from(doc.querySelectorAll(\"[id]\")).forEach((elem) => {\n      const id = elem.getAttribute(\"id\");\n      const newId = `${id}_${counter.incr()}`;\n      elem.setAttribute(\"id\", newId);\n\n      idMap[id] = newId;\n    });\n  }\n\n  Array.from(doc.querySelectorAll(\"*\")).forEach((elem) => {\n    // Unless explicitly set, remove JS code (default)\n    if (elem.tagName === \"script\") {\n      if (!enableJs) {\n        elem.remove();\n        return;\n      } else {\n        const scriptEl = document.createElement(\"script\");\n        scriptEl.innerHTML = elem.innerHTML;\n        document.body.appendChild(scriptEl);\n      }\n    }\n\n    for (let i = 0; i < elem.attributes.length; i++) {\n      const { name, value } = elem.attributes[i];\n\n      const newValue = cssUrlFixer(idMap, value, name);\n\n      if (value !== newValue) {\n        elem.setAttribute(name, newValue);\n      }\n\n      // Remove event functions: onmouseover, onclick ... unless specifically enabled\n      if (eventNames.includes(name.toLowerCase()) && !enableJs) {\n        elem.removeAttribute(name);\n        continue;\n      }\n\n      // Remove \"javascript:...\" unless specifically enabled\n      if (\n        [\"href\", \"xlink:href\"].includes(name) &&\n        value.startsWith(\"javascript\") &&\n        !enableJs\n      ) {\n        elem.removeAttribute(name);\n      }\n    }\n\n    // .first -> [data-id=\"svg_loader_341xx\"] .first\n    // Makes sure that class names don't conflict with each other.\n    if (elem.tagName === \"style\" && !disableCssScoping) {\n      let newValue = cssScope(\n        elem.innerHTML,\n        `[data-id=\"${elemUniqueId}\"]`,\n        idMap\n      );\n      newValue = cssUrlFixer(idMap, newValue);\n      if (newValue !== elem.innerHTML) elem.innerHTML = newValue;\n    }\n  });\n\n  for (let i = 0; i < fragment.attributes.length; i++) {\n    const { name, value } = fragment.attributes[i];\n\n    // Don't override the attributes already defined, but override the ones that\n    // were in the original element\n    if (!elem.getAttribute(name) || elemAttributesSet.has(name)) {\n      elemAttributesSet.add(name);\n      elem.setAttribute(name, value);\n    }\n  }\n\n  attributesSet[elemUniqueId] = elemAttributesSet;\n\n  elem.setAttribute(\"data-id\", elemUniqueId);\n  elem.innerHTML = fragment.innerHTML;\n\n  const event = new CustomEvent(\"iconload\", {\n    bubbles: true,\n  });\n  elem.dispatchEvent(event);\n\n  if (elem.getAttribute(\"oniconload\")) {\n    // Handling (and executing) event attribute for our event (oniconload)\n    // isn't straightforward. Because a) the code is a raw string b) there's\n    // no way to specify the context for execution. So, `this` in the attribute\n    // will point to `window` instead of the element itself.\n    //\n    // Here we are recycling a rarely used GlobalEventHandler 'onloadedmetadata'\n    // and offloading the execution to the browser. This is a hack, but because\n    // the event doesn't bubble, it shouldn't affect anything else in the code.\n    elem.setAttribute(\"onloadedmetadata\", elem.getAttribute(\"oniconload\"));\n\n    const event = new CustomEvent(\"loadedmetadata\", {\n      bubbles: false,\n    });\n    elem.dispatchEvent(event);\n\n    elem.removeAttribute(\"onloadedmetadata\");\n  }\n};\n\nconst requestsInProgress = {};\nconst memoryCache = {};\n\nconst renderIcon = async (elem) => {\n  const src = elem.getAttribute(\"data-src\");\n  const cacheOpt = elem.getAttribute(\"data-cache\");\n\n  const enableJs = elem.getAttribute(\"data-js\") === \"enabled\";\n  const disableUniqueIds = elem.getAttribute(\"data-unique-ids\") === \"disabled\";\n  const disableCssScoping =\n    elem.getAttribute(\"data-css-scoping\") === \"disabled\";\n\n  const lsCache = await isCacheAvailable(src);\n  const isCachingEnabled = cacheOpt !== \"disabled\";\n\n  const renderBodyCb = renderBody.bind(self, elem, {\n    enableJs,\n    disableUniqueIds,\n    disableCssScoping,\n  });\n\n  // Memory cache optimizes same icon requested multiple\n  // times on the page\n  if (memoryCache[src] || (isCachingEnabled && lsCache)) {\n    const cache = memoryCache[src] || lsCache;\n\n    renderBodyCb(cache);\n  } else {\n    // If the same icon is being requested to rendered\n    // avoid firing multiple XHRs\n    if (requestsInProgress[src]) {\n      setTimeout(() => renderIcon(elem), 20);\n      return;\n    }\n\n    requestsInProgress[src] = true;\n\n    fetch(src)\n      .then((response) => {\n        if (!response.ok) {\n          throw Error(\n            `Request for '${src}' returned ${response.status} (${response.statusText})`\n          );\n        }\n        return response.text();\n      })\n      .then((body) => {\n        const bodyLower = body.toLowerCase().trim();\n\n        if (!(bodyLower.startsWith(\"<svg\") || bodyLower.startsWith(\"<?xml\"))) {\n          throw Error(`Resource '${src}' returned an invalid SVG file`);\n        }\n\n        if (isCachingEnabled) {\n          setCache(src, body, cacheOpt);\n        }\n\n        memoryCache[src] = body;\n\n        renderBodyCb(body);\n      })\n      .catch((e) => {\n        console.error(e);\n      })\n      .finally(() => {\n        delete requestsInProgress[src];\n      });\n  }\n};\n\nlet intObserver;\nif (globalThis.IntersectionObserver) {\n  const intObserver = new IntersectionObserver(\n    (entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          renderIcon(entry.target);\n\n          // Unobserve as soon as soon the icon is rendered\n          intObserver.unobserve(entry.target);\n        }\n      });\n    },\n    {\n      // Keep high root margin because intersection observer\n      // can be slow to react\n      rootMargin: \"1200px\",\n    }\n  );\n}\n\nconst handled = [];\nfunction renderAllSVGs() {\n  Array.from(document.querySelectorAll(\"svg[data-src]:not([data-id])\")).forEach(\n    (element) => {\n      if (handled.indexOf(element) !== -1) {\n        return;\n      }\n\n      handled.push(element);\n      if (element.getAttribute(\"data-loading\") === \"lazy\") {\n        intObserver.observe(element);\n      } else {\n        renderIcon(element);\n      }\n    }\n  );\n}\n\nlet observerAdded = false;\nconst addObservers = () => {\n  if (observerAdded) {\n    return;\n  }\n\n  observerAdded = true;\n  const observer = new MutationObserver((mutationRecords) => {\n    const shouldTriggerRender = mutationRecords.some((record) =>\n      Array.from(record.addedNodes).some(\n        (elem) =>\n          elem.nodeType === Node.ELEMENT_NODE &&\n          ((elem.getAttribute(\"data-src\") && !elem.getAttribute(\"data-id\")) || // Check if the element needs to be rendered\n            elem.querySelector(\"svg[data-src]:not([data-id])\")) // Check if any of the element's children need to be rendered\n      )\n    );\n\n    // If any node is added, render all new nodes because the nodes that have already\n    // been rendered won't be rendered again.\n    if (shouldTriggerRender) {\n      renderAllSVGs();\n    }\n\n    // If data-src is changed, re-render\n    mutationRecords.forEach((record) => {\n      if (record.type === \"attributes\") {\n        renderIcon(record.target);\n      }\n    });\n  });\n\n  observer.observe(document.documentElement, {\n    attributeFilter: [\"data-src\"],\n    attributes: true,\n    childList: true,\n    subtree: true,\n  });\n};\n\nif (globalThis.addEventListener) {\n  // Start rendering SVGs as soon as possible\n  const intervalCheck = setInterval(() => {\n    renderAllSVGs();\n  }, 100);\n\n  globalThis.addEventListener(\"DOMContentLoaded\", () => {\n    clearInterval(intervalCheck);\n\n    renderAllSVGs();\n    addObservers();\n  });\n}\n"],"names":[],"sourceRoot":""}