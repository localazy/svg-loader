{"version":3,"file":"svg-loader.js","mappings":";;;;;;;;;;AAAa;;AAEb;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;;;;;;;;;;AChBa;;AAEb;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;ACxCa;;AAEb;AACA;AACA,qCAAqC,WAAW,GAAG,MAAM;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0CAA0C,gBAAgB;AAC1D;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;;;;;;;;;;;ACxBa;AACb,qBAAqB,mBAAO,CAAC,uDAAiB;AAC9C,kBAAkB,mBAAO,CAAC,iDAAc;AACxC,oBAAoB,mBAAO,CAAC,qDAAgB;;AAE5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;ACxBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;;AAEP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA,GAAG;AACH;;;;;;;;;;ACxBA;AACA;AACA;AACA,eAAe;AACf,eAAe;AACf;AACA,KAAK;AACL;AACA;;;;;;UCRA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;ACtBa;;AAEb,iBAAiB,mBAAO,CAAC,2CAAiB;AAC1C,oBAAoB,mBAAO,CAAC,mDAAqB;AACjD,gBAAgB,mBAAO,CAAC,uCAAe;AACvC,QAAQ,aAAa,EAAE,mBAAO,CAAC,6CAAe;;AAE9C;;;;AAIA;AACA;AACA;AACA,2CAA2C,IAAI;;AAE/C;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN,4BAA4B,IAAI;AAChC;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU,gDAAgD;;AAE1D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,eAAe;;AAEjE;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,GAAG,GAAG,eAAe;AAC5C;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,4BAA4B;AAChD,cAAc,cAAc;;AAE5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,kBAAkB,gCAAgC;AAClD,YAAY,cAAc;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,IAAI,aAAa,iBAAiB,GAAG,oBAAoB;AACrF;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,mCAAmC,IAAI;AACvC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,GAAG;AACH","sources":["webpack://@localazy/svg-loader/./lib/counter.js","webpack://@localazy/svg-loader/./lib/css-url-fixer.js","webpack://@localazy/svg-loader/./lib/scope-css.js","webpack://@localazy/svg-loader/./lib/storage/index.js","webpack://@localazy/svg-loader/./lib/storage/indexed-db.js","webpack://@localazy/svg-loader/./lib/storage/local-storage.js","webpack://@localazy/svg-loader/./lib/storage/mock-storage.js","webpack://@localazy/svg-loader/webpack/bootstrap","webpack://@localazy/svg-loader/./svg-loader.js"],"sourcesContent":["\"use strict\";\n\nlet counter = 0;\n\nmodule.exports = {\n    incr () {\n        return ++counter;\n    },\n\n    decr () {\n        return --counter;\n    },\n\n    curr () {\n        return counter;\n    }\n};","\"use strict\";\n\n/**\n * Handle all SVG references correctly, which can be\n *   a) via attributes: url(#abc)\n *   b) via tags: <use href=\"#abc\" />\n *   c) via css: .class { fill: url(#abc) }\n * @param {object} idMap: Map previous id with the new unique id\n * @param {string} attributeValueOrCSS\n * @param {string} attributeName\n * @returns attribute or css value with correct id\n */\nmodule.exports = (idMap, attributeValueOrCSS, attributeName = \"\") => {\n    const svgRefRegex = /url\\(['\"]?#([\\w:.-]+)['\"]?\\)/g;\n    const urlRefRegex = /#([\\w:.-]+)/g;\n\n    // fill=\"url(#abc)\" -> fill=\"url(#abc_2)\"\n    // Use the unique IDs created previously\n    if (attributeValueOrCSS.match(svgRefRegex)) {\n        attributeValueOrCSS = attributeValueOrCSS.replace(svgRefRegex, function (g0, g1) {\n            if (!idMap[g1]) {\n                return g0;\n            }\n            return `url(#${idMap[g1]})`;\n        });\n    }\n\n    // <use href=\"#X\" -> <use href=\"#X_23\"\n    // Use the unique IDs created previously\n    if ([\"href\", \"xlink:href\"].includes(attributeName)) {\n        if (attributeValueOrCSS.match(urlRefRegex)) {\n            attributeValueOrCSS = attributeValueOrCSS.replace(urlRefRegex, function (g0, g1) {\n                if (!idMap[g1]) {\n                    return g0;\n                }\n                return `#${idMap[g1]}`;\n            });\n        }\n    }\n    return attributeValueOrCSS;\n};\n","\"use strict\";\n\n// Source: https://github.com/thomaspark/scoper\nmodule.exports = (css, prefix, idMap) => {\n    const re = new RegExp(\"([^\\r\\n,{}]+)(,(?=[^}]*{)|\\s*{)\", \"g\");\n    css = css.replace(re, function (g0, g1, g2) {\n\n        if (g1.match(/^\\s*(@media|@.*keyframes|to|from|@font-face|1?[0-9]?[0-9])/)) {\n            return g1 + g2;\n        }\n\n        const idRegex = /#(\\w+)/;\n        const match = g1.match(idRegex);\n\n        if (match && idMap[match[1]]) {\n            g1 = g1.replace(match[0], `#${idMap[match[1]]}`);\n        }\n\n        g1 = g1.replace(/^(\\s*)/, \"$1\" + prefix + \" \");\n\n        return g1 + g2;\n    });\n\n    return css;\n};","\"use strict\";\nconst localStorage = require(\"./local-storage\");\nconst indexedDB = require(\"./indexed-db\");\nconst mockStorage = require(\"./mock-storage\");\n\nlet storage = null;\n\nconst getAvailableStorage = async (name) => {\n  if (await indexedDB.hasStorage(name)) {\n    return indexedDB.getStorage(name)\n  }\n  else if (await localStorage.hasStorage()) {\n    return localStorage.getStorage(name)\n  }\n  return mockStorage.getStorage()\n}\n\n\nconst getStorage = async (name) => {\n  return storage || await getAvailableStorage(name)\n}\n\nmodule.exports = {\n  getStorage,\n}","let db = null;\n\n/**\n * Work around Safari 14 IndexedDB open bug.\n *\n * Safari has a horrible bug where IDB requests can hang while the browser is starting up. https://bugs.webkit.org/show_bug.cgi?id=226547\n * The only solution is to keep nudging it until it's awake.\n */\nconst idbReady = () => {\n  const isSafari =\n    !navigator.userAgentData &&\n    /Safari\\//.test(navigator.userAgent) &&\n    !/Chrom(e|ium)\\//.test(navigator.userAgent);\n\n  // No point putting other browsers or older versions of Safari through this mess.\n  if (!isSafari || !indexedDB.databases) return Promise.resolve();\n\n  let intervalId;\n\n  return new Promise((resolve) => {\n    const tryIdb = () => indexedDB.databases().finally(resolve);\n    intervalId = setInterval(tryIdb, 100);\n    tryIdb();\n  }).finally(() => clearInterval(intervalId));\n}\n\nconst openDBConnection = async (name) => {\n  try {\n    await idbReady(name);\n    return createStore(name);\n  }\n  catch (e) {\n    console.log(\"cannot create store\");\n  }\n}\n\nconst getObjectStore = async (name, mode = \"readonly\") => {\n  db = db || await openDBConnection(name);\n  const transaction = await db.transaction([name], mode);\n  return transaction.objectStore(name);\n}\n\nconst createStore = (name) => {\n  return new Promise((resolve, reject) => {\n    const request = window.indexedDB.open(name, 1);\n    request.onupgradeneeded = () => {\n      request.result.createObjectStore(name);\n    };\n    request.onsuccess = () => resolve(request.result);\n    request.onerror = () => reject(request.error);\n  });\n}\n\nconst transaction = async (name, method, mode, value, key) => {\n  const objectStore = await getObjectStore(name, mode)\n  return new Promise((resolve, reject) => {\n    const request = objectStore[method](value, key)\n    request.onsuccess = () => resolve(request.result);\n    request.onerror = () => reject(request.error);\n  });\n}\n\n\nmodule.exports = {\n  getStorage: (name) => {\n    return ({\n      async get(key) {\n        return transaction(name, \"get\", \"readonly\", key);\n      },\n      async set(key, value) {\n        return transaction(name, \"put\", \"readwrite\", value, key)\n      },\n      async del(key) {\n        return transaction(name, \"delete\", \"readwrite\", key);\n      },\n\n    })\n  },\n  hasStorage: async (name) => {\n    if (indexedDB) {\n      try {\n        await getObjectStore(name)\n        return true;\n      }\n      catch { }\n    }\n    return false;\n  },\n};","module.exports = {\n  getStorage: () => {\n    return ({\n      get(key) {\n        return JSON.parse(localStorage.getItem(key));\n      },\n      set(key, value) {\n        localStorage.setItem(key, JSON.stringify(value));\n      },\n      del(key) {\n        localStorage.removeItem(key);\n      },\n    });\n  },\n  hasStorage: async () => {\n    try {\n      localStorage.setItem('test', 'test');\n      localStorage.removeItem('test');\n      return true;\n    } catch (e) {\n      return false;\n    }\n\n  },\n};","module.exports = {\n  getStorage: () => {\n    return ({\n      get() { },\n      set() { },\n      del() { }\n    });\n  }\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\n\nconst cssScope = require(\"./lib/scope-css\");\nconst cssUrlFixer = require(\"./lib/css-url-fixer\");\nconst counter = require(\"./lib/counter\");\nconst { getStorage } = require(\"./lib/storage\");\n\nconst STORAGE_NAME = \"svg-loader-cache\";\n\n\n\nconst isCacheAvailable = async (url) => {\n  try {\n    const storage = await getStorage(STORAGE_NAME);\n    let item = await storage.get(`loader_${url}`);\n\n    if (!item) {\n      return;\n    }\n\n    item = JSON.parse(item);\n\n    if (Date.now() < item.expiry) {\n      return item.data;\n    } else {\n      storage.del(`loader_${url}`);\n      return;\n    }\n  } catch (e) {\n    return;\n  }\n};\n\nconst setCache = async (url, data, cacheOpt) => {\n  try {\n    const storage = await getStorage(STORAGE_NAME);\n    const cacheExp = parseInt(cacheOpt, 10);\n\n    await storage.set(\n      `loader_${url}`,\n      JSON.stringify({\n        data,\n        expiry:\n          Date.now() +\n          (Number.isNaN(cacheExp) ? 60 * 60 * 1000 * 24 : cacheExp),\n      })\n    );\n  } catch (e) {\n    console.error(e);\n  }\n};\n\nconst DOM_EVENTS = [];\nconst getAllEventNames = () => {\n  if (DOM_EVENTS.length) {\n    return DOM_EVENTS;\n  }\n\n  for (const prop in document.head) {\n    if (prop.startsWith(\"on\")) {\n      DOM_EVENTS.push(prop);\n    }\n  }\n\n  return DOM_EVENTS;\n};\n\nconst attributesSet = {};\nconst renderBody = (elem, options, body) => {\n  const { enableJs, disableUniqueIds, disableCssScoping } = options;\n\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(body, \"text/html\");\n  const fragment = doc.querySelector(\"svg\");\n\n  const eventNames = getAllEventNames();\n\n  // When svg-loader is loading in the same element, it's\n  // important to keep track of original properties.\n  const elemAttributesSet =\n    attributesSet[elem.getAttribute(\"data-id\")] || new Set();\n\n  const elemUniqueId =\n    elem.getAttribute(\"data-id\") || `svg-loader_${counter.incr()}`;\n\n  const idMap = {};\n\n  if (!disableUniqueIds) {\n    // Append a unique suffix for every ID so elements don't conflict.\n    Array.from(doc.querySelectorAll(\"[id]\")).forEach((elem) => {\n      const id = elem.getAttribute(\"id\");\n      const newId = `${id}_${counter.incr()}`;\n      elem.setAttribute(\"id\", newId);\n\n      idMap[id] = newId;\n    });\n  }\n\n  Array.from(doc.querySelectorAll(\"*\")).forEach((elem) => {\n    // Unless explicitly set, remove JS code (default)\n    if (elem.tagName === \"script\") {\n      if (!enableJs) {\n        elem.remove();\n        return;\n      } else {\n        const scriptEl = document.createElement(\"script\");\n        scriptEl.innerHTML = elem.innerHTML;\n        document.body.appendChild(scriptEl);\n      }\n    }\n\n    for (let i = 0; i < elem.attributes.length; i++) {\n      const { name, value } = elem.attributes[i];\n\n      const newValue = cssUrlFixer(idMap, value, name);\n\n      if (value !== newValue) {\n        elem.setAttribute(name, newValue);\n      }\n\n      // Remove event functions: onmouseover, onclick ... unless specifically enabled\n      if (eventNames.includes(name.toLowerCase()) && !enableJs) {\n        elem.removeAttribute(name);\n        continue;\n      }\n\n      // Remove \"javascript:...\" unless specifically enabled\n      if (\n        [\"href\", \"xlink:href\"].includes(name) &&\n        value.startsWith(\"javascript\") &&\n        !enableJs\n      ) {\n        elem.removeAttribute(name);\n      }\n    }\n\n    // .first -> [data-id=\"svg_loader_341xx\"] .first\n    // Makes sure that class names don't conflict with each other.\n    if (elem.tagName === \"style\" && !disableCssScoping) {\n      let newValue = cssScope(\n        elem.innerHTML,\n        `[data-id=\"${elemUniqueId}\"]`,\n        idMap\n      );\n      newValue = cssUrlFixer(idMap, newValue);\n      if (newValue !== elem.innerHTML) elem.innerHTML = newValue;\n    }\n  });\n\n  for (let i = 0; i < fragment.attributes.length; i++) {\n    const { name, value } = fragment.attributes[i];\n\n    // Don't override the attributes already defined, but override the ones that\n    // were in the original element\n    if (!elem.getAttribute(name) || elemAttributesSet.has(name)) {\n      elemAttributesSet.add(name);\n      elem.setAttribute(name, value);\n    }\n  }\n\n  attributesSet[elemUniqueId] = elemAttributesSet;\n\n  elem.setAttribute(\"data-id\", elemUniqueId);\n  elem.innerHTML = fragment.innerHTML;\n\n  const event = new CustomEvent(\"iconload\", {\n    bubbles: true,\n  });\n  elem.dispatchEvent(event);\n\n  if (elem.getAttribute(\"oniconload\")) {\n    // Handling (and executing) event attribute for our event (oniconload)\n    // isn't straightforward. Because a) the code is a raw string b) there's\n    // no way to specify the context for execution. So, `this` in the attribute\n    // will point to `window` instead of the element itself.\n    //\n    // Here we are recycling a rarely used GlobalEventHandler 'onloadedmetadata'\n    // and offloading the execution to the browser. This is a hack, but because\n    // the event doesn't bubble, it shouldn't affect anything else in the code.\n    elem.setAttribute(\"onloadedmetadata\", elem.getAttribute(\"oniconload\"));\n\n    const event = new CustomEvent(\"loadedmetadata\", {\n      bubbles: false,\n    });\n    elem.dispatchEvent(event);\n\n    elem.removeAttribute(\"onloadedmetadata\");\n  }\n};\n\nconst requestsInProgress = {};\nconst memoryCache = {};\n\nconst renderIcon = async (elem) => {\n  const src = elem.getAttribute(\"data-src\");\n  const cacheOpt = elem.getAttribute(\"data-cache\");\n\n  const enableJs = elem.getAttribute(\"data-js\") === \"enabled\";\n  const disableUniqueIds = elem.getAttribute(\"data-unique-ids\") === \"disabled\";\n  const disableCssScoping =\n    elem.getAttribute(\"data-css-scoping\") === \"disabled\";\n\n  const lsCache = await isCacheAvailable(src);\n  const isCachingEnabled = cacheOpt !== \"disabled\";\n\n  const renderBodyCb = renderBody.bind(self, elem, {\n    enableJs,\n    disableUniqueIds,\n    disableCssScoping,\n  });\n\n  // Memory cache optimizes same icon requested multiple\n  // times on the page\n  if (memoryCache[src] || (isCachingEnabled && lsCache)) {\n    const cache = memoryCache[src] || lsCache;\n\n    renderBodyCb(cache);\n  } else {\n    // If the same icon is being requested to rendered\n    // avoid firing multiple XHRs\n    if (requestsInProgress[src]) {\n      setTimeout(() => renderIcon(elem), 20);\n      return;\n    }\n\n    requestsInProgress[src] = true;\n\n    fetch(src)\n      .then((response) => {\n        if (!response.ok) {\n          throw Error(\n            `Request for '${src}' returned ${response.status} (${response.statusText})`\n          );\n        }\n        return response.text();\n      })\n      .then((body) => {\n        const bodyLower = body.toLowerCase().trim();\n\n        if (!(bodyLower.startsWith(\"<svg\") || bodyLower.startsWith(\"<?xml\"))) {\n          throw Error(`Resource '${src}' returned an invalid SVG file`);\n        }\n\n        if (isCachingEnabled) {\n          setCache(src, body, cacheOpt);\n        }\n\n        memoryCache[src] = body;\n\n        renderBodyCb(body);\n      })\n      .catch((e) => {\n        console.error(e);\n      })\n      .finally(() => {\n        delete requestsInProgress[src];\n      });\n  }\n};\n\nlet intObserver;\nif (globalThis.IntersectionObserver) {\n  intObserver = new IntersectionObserver(\n    (entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          renderIcon(entry.target);\n\n          // Unobserve as soon as soon the icon is rendered\n          intObserver.unobserve(entry.target);\n        }\n      });\n    },\n    {\n      // Keep high root margin because intersection observer\n      // can be slow to react\n      rootMargin: \"1200px\",\n    }\n  );\n}\n\nconst handled = [];\nfunction renderAllSVGs() {\n  Array.from(document.querySelectorAll(\"svg[data-src]:not([data-id])\")).forEach(\n    (element) => {\n      if (handled.indexOf(element) !== -1) {\n        return;\n      }\n\n      handled.push(element);\n      if (element.getAttribute(\"data-loading\") === \"lazy\") {\n        intObserver.observe(element);\n      } else {\n        renderIcon(element);\n      }\n    }\n  );\n}\n\nlet observerAdded = false;\nconst addObservers = () => {\n  if (observerAdded) {\n    return;\n  }\n\n  observerAdded = true;\n  const observer = new MutationObserver((mutationRecords) => {\n    const shouldTriggerRender = mutationRecords.some((record) =>\n      Array.from(record.addedNodes).some(\n        (elem) =>\n          elem.nodeType === Node.ELEMENT_NODE &&\n          ((elem.getAttribute(\"data-src\") && !elem.getAttribute(\"data-id\")) || // Check if the element needs to be rendered\n            elem.querySelector(\"svg[data-src]:not([data-id])\")) // Check if any of the element's children need to be rendered\n      )\n    );\n\n    // If any node is added, render all new nodes because the nodes that have already\n    // been rendered won't be rendered again.\n    if (shouldTriggerRender) {\n      renderAllSVGs();\n    }\n\n    // If data-src is changed, re-render\n    mutationRecords.forEach((record) => {\n      if (record.type === \"attributes\") {\n        renderIcon(record.target);\n      }\n    });\n  });\n\n  observer.observe(document.documentElement, {\n    attributeFilter: [\"data-src\"],\n    attributes: true,\n    childList: true,\n    subtree: true,\n  });\n};\n\nif (globalThis.addEventListener) {\n  // Start rendering SVGs as soon as possible\n  const intervalCheck = setInterval(() => {\n    renderAllSVGs();\n  }, 100);\n\n  globalThis.addEventListener(\"DOMContentLoaded\", () => {\n    clearInterval(intervalCheck);\n\n    renderAllSVGs();\n    addObservers();\n  });\n}\n"],"names":[],"sourceRoot":""}