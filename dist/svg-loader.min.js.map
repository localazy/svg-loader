{"version":3,"file":"svg-loader.min.js","mappings":"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","sources":["webpack://@localazy/svg-loader/./lib/counter.js","webpack://@localazy/svg-loader/./lib/css-url-fixer.js","webpack://@localazy/svg-loader/./lib/scope-css.js","webpack://@localazy/svg-loader/./lib/storage/index.js","webpack://@localazy/svg-loader/./lib/storage/indexed-db.js","webpack://@localazy/svg-loader/./lib/storage/local-storage.js","webpack://@localazy/svg-loader/./lib/storage/mock-storage.js","webpack://@localazy/svg-loader/webpack/bootstrap","webpack://@localazy/svg-loader/./svg-loader.js"],"sourcesContent":["\"use strict\";\n\nlet counter = 0;\n\nmodule.exports = {\n    incr () {\n        return ++counter;\n    },\n\n    decr () {\n        return --counter;\n    },\n\n    curr () {\n        return counter;\n    }\n};","\"use strict\";\n\n/**\n * Handle all SVG references correctly, which can be\n *   a) via attributes: url(#abc)\n *   b) via tags: <use href=\"#abc\" />\n *   c) via css: .class { fill: url(#abc) }\n * @param {object} idMap: Map previous id with the new unique id\n * @param {string} attributeValueOrCSS\n * @param {string} attributeName\n * @returns attribute or css value with correct id\n */\nmodule.exports = (idMap, attributeValueOrCSS, attributeName = \"\") => {\n    const svgRefRegex = /url\\(['\"]?#([\\w:.-]+)['\"]?\\)/g;\n    const urlRefRegex = /#([\\w:.-]+)/g;\n\n    // fill=\"url(#abc)\" -> fill=\"url(#abc_2)\"\n    // Use the unique IDs created previously\n    if (attributeValueOrCSS.match(svgRefRegex)) {\n        attributeValueOrCSS = attributeValueOrCSS.replace(svgRefRegex, function (g0, g1) {\n            if (!idMap[g1]) {\n                return g0;\n            }\n            return `url(#${idMap[g1]})`;\n        });\n    }\n\n    // <use href=\"#X\" -> <use href=\"#X_23\"\n    // Use the unique IDs created previously\n    if ([\"href\", \"xlink:href\"].includes(attributeName)) {\n        if (attributeValueOrCSS.match(urlRefRegex)) {\n            attributeValueOrCSS = attributeValueOrCSS.replace(urlRefRegex, function (g0, g1) {\n                if (!idMap[g1]) {\n                    return g0;\n                }\n                return `#${idMap[g1]}`;\n            });\n        }\n    }\n    return attributeValueOrCSS;\n};\n","\"use strict\";\n\n// Source: https://github.com/thomaspark/scoper\nmodule.exports = (css, prefix, idMap) => {\n    const re = new RegExp(\"([^\\r\\n,{}]+)(,(?=[^}]*{)|\\s*{)\", \"g\");\n    css = css.replace(re, function (g0, g1, g2) {\n\n        if (g1.match(/^\\s*(@media|@.*keyframes|to|from|@font-face|1?[0-9]?[0-9])/)) {\n            return g1 + g2;\n        }\n\n        const idRegex = /#(\\w+)/;\n        const match = g1.match(idRegex);\n\n        if (match && idMap[match[1]]) {\n            g1 = g1.replace(match[0], `#${idMap[match[1]]}`);\n        }\n\n        g1 = g1.replace(/^(\\s*)/, \"$1\" + prefix + \" \");\n\n        return g1 + g2;\n    });\n\n    return css;\n};","\"use strict\";\nconst localStorage = require(\"./local-storage\");\nconst indexedDB = require(\"./indexed-db\");\nconst mockStorage = require(\"./mock-storage\");\n\nlet storage = null;\n\nconst getAvailableStorage = async (name) => {\n  if (await indexedDB.hasStorage(name)) {\n    return indexedDB.getStorage(name)\n  }\n  else if (await localStorage.hasStorage()) {\n    return localStorage.getStorage(name)\n  }\n  return mockStorage.getStorage()\n}\n\n\nconst getStorage = async (name) => {\n  return storage || await getAvailableStorage(name)\n}\n\nmodule.exports = {\n  getStorage,\n}","let db = null;\n\n/**\n * Work around Safari 14 IndexedDB open bug.\n *\n * Safari has a horrible bug where IDB requests can hang while the browser is starting up. https://bugs.webkit.org/show_bug.cgi?id=226547\n * The only solution is to keep nudging it until it's awake.\n */\nconst idbReady = () => {\n  const isSafari =\n    !navigator.userAgentData &&\n    /Safari\\//.test(navigator.userAgent) &&\n    !/Chrom(e|ium)\\//.test(navigator.userAgent);\n\n  // No point putting other browsers or older versions of Safari through this mess.\n  if (!isSafari || !indexedDB.databases) return Promise.resolve();\n\n  let intervalId;\n\n  return new Promise((resolve) => {\n    const tryIdb = () => indexedDB.databases().finally(resolve);\n    intervalId = setInterval(tryIdb, 100);\n    tryIdb();\n  }).finally(() => clearInterval(intervalId));\n}\n\nconst openDBConnection = async (name) => {\n  try {\n    await idbReady(name);\n    return createStore(name);\n  }\n  catch (e) {\n    console.log(\"cannot create store\");\n  }\n}\n\nconst getObjectStore = async (name, mode = \"readonly\") => {\n  db = db || await openDBConnection(name);\n  const transaction = await db.transaction([name], mode);\n  return transaction.objectStore(name);\n}\n\nconst createStore = (name) => {\n  return new Promise((resolve, reject) => {\n    const request = window.indexedDB.open(name, 1);\n    request.onupgradeneeded = () => {\n      request.result.createObjectStore(name);\n    };\n    request.onsuccess = () => resolve(request.result);\n    request.onerror = () => reject(request.error);\n  });\n}\n\nconst transaction = async (name, method, mode, value, key) => {\n  const objectStore = await getObjectStore(name, mode)\n  return new Promise((resolve, reject) => {\n    const request = objectStore[method](value, key)\n    request.onsuccess = () => resolve(request.result);\n    request.onerror = () => reject(request.error);\n  });\n}\n\n\nmodule.exports = {\n  getStorage: (name) => {\n    return ({\n      async get(key) {\n        return transaction(name, \"get\", \"readonly\", key);\n      },\n      async set(key, value) {\n        return transaction(name, \"put\", \"readwrite\", value, key)\n      },\n      async del(key) {\n        return transaction(name, \"delete\", \"readwrite\", key);\n      },\n\n    })\n  },\n  hasStorage: async (name) => {\n    if (indexedDB) {\n      try {\n        await getObjectStore(name)\n        return true;\n      }\n      catch { }\n    }\n    return false;\n  },\n};","module.exports = {\n  getStorage: () => {\n    return ({\n      get(key) {\n        return JSON.parse(localStorage.getItem(key));\n      },\n      set(key, value) {\n        localStorage.setItem(key, JSON.stringify(value));\n      },\n      del(key) {\n        localStorage.removeItem(key);\n      },\n    });\n  },\n  hasStorage: async () => {\n    try {\n      localStorage.setItem('test', 'test');\n      localStorage.removeItem('test');\n      return true;\n    } catch (e) {\n      return false;\n    }\n\n  },\n};","module.exports = {\n  getStorage: () => {\n    return ({\n      get() { },\n      set() { },\n      del() { }\n    });\n  }\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\n\nconst cssScope = require(\"./lib/scope-css\");\nconst cssUrlFixer = require(\"./lib/css-url-fixer\");\nconst counter = require(\"./lib/counter\");\nconst { getStorage } = require(\"./lib/storage\");\n\nconst STORAGE_NAME = \"svg-loader-cache\";\n\n\n\nconst isCacheAvailable = async (url) => {\n  try {\n    const storage = await getStorage(STORAGE_NAME);\n    let item = await storage.get(`loader_${url}`);\n\n    if (!item) {\n      return;\n    }\n\n    item = JSON.parse(item);\n\n    if (Date.now() < item.expiry) {\n      return item.data;\n    } else {\n      storage.del(`loader_${url}`);\n      return;\n    }\n  } catch (e) {\n    return;\n  }\n};\n\nconst setCache = async (url, data, cacheOpt) => {\n  try {\n    const storage = await getStorage(STORAGE_NAME);\n    const cacheExp = parseInt(cacheOpt, 10);\n\n    await storage.set(\n      `loader_${url}`,\n      JSON.stringify({\n        data,\n        expiry:\n          Date.now() +\n          (Number.isNaN(cacheExp) ? 60 * 60 * 1000 * 24 : cacheExp),\n      })\n    );\n  } catch (e) {\n    console.error(e);\n  }\n};\n\nconst DOM_EVENTS = [];\nconst getAllEventNames = () => {\n  if (DOM_EVENTS.length) {\n    return DOM_EVENTS;\n  }\n\n  for (const prop in document.head) {\n    if (prop.startsWith(\"on\")) {\n      DOM_EVENTS.push(prop);\n    }\n  }\n\n  return DOM_EVENTS;\n};\n\nconst attributesSet = {};\nconst renderBody = (elem, options, body) => {\n  const { enableJs, disableUniqueIds, disableCssScoping } = options;\n\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(body, \"text/html\");\n  const fragment = doc.querySelector(\"svg\");\n\n  const eventNames = getAllEventNames();\n\n  // When svg-loader is loading in the same element, it's\n  // important to keep track of original properties.\n  const elemAttributesSet =\n    attributesSet[elem.getAttribute(\"data-id\")] || new Set();\n\n  const elemUniqueId =\n    elem.getAttribute(\"data-id\") || `svg-loader_${counter.incr()}`;\n\n  const idMap = {};\n\n  if (!disableUniqueIds) {\n    // Append a unique suffix for every ID so elements don't conflict.\n    Array.from(doc.querySelectorAll(\"[id]\")).forEach((elem) => {\n      const id = elem.getAttribute(\"id\");\n      const newId = `${id}_${counter.incr()}`;\n      elem.setAttribute(\"id\", newId);\n\n      idMap[id] = newId;\n    });\n  }\n\n  Array.from(doc.querySelectorAll(\"*\")).forEach((elem) => {\n    // Unless explicitly set, remove JS code (default)\n    if (elem.tagName === \"script\") {\n      if (!enableJs) {\n        elem.remove();\n        return;\n      } else {\n        const scriptEl = document.createElement(\"script\");\n        scriptEl.innerHTML = elem.innerHTML;\n        document.body.appendChild(scriptEl);\n      }\n    }\n\n    for (let i = 0; i < elem.attributes.length; i++) {\n      const { name, value } = elem.attributes[i];\n\n      const newValue = cssUrlFixer(idMap, value, name);\n\n      if (value !== newValue) {\n        elem.setAttribute(name, newValue);\n      }\n\n      // Remove event functions: onmouseover, onclick ... unless specifically enabled\n      if (eventNames.includes(name.toLowerCase()) && !enableJs) {\n        elem.removeAttribute(name);\n        continue;\n      }\n\n      // Remove \"javascript:...\" unless specifically enabled\n      if (\n        [\"href\", \"xlink:href\"].includes(name) &&\n        value.startsWith(\"javascript\") &&\n        !enableJs\n      ) {\n        elem.removeAttribute(name);\n      }\n    }\n\n    // .first -> [data-id=\"svg_loader_341xx\"] .first\n    // Makes sure that class names don't conflict with each other.\n    if (elem.tagName === \"style\" && !disableCssScoping) {\n      let newValue = cssScope(\n        elem.innerHTML,\n        `[data-id=\"${elemUniqueId}\"]`,\n        idMap\n      );\n      newValue = cssUrlFixer(idMap, newValue);\n      if (newValue !== elem.innerHTML) elem.innerHTML = newValue;\n    }\n  });\n\n  for (let i = 0; i < fragment.attributes.length; i++) {\n    const { name, value } = fragment.attributes[i];\n\n    // Don't override the attributes already defined, but override the ones that\n    // were in the original element\n    if (!elem.getAttribute(name) || elemAttributesSet.has(name)) {\n      elemAttributesSet.add(name);\n      elem.setAttribute(name, value);\n    }\n  }\n\n  attributesSet[elemUniqueId] = elemAttributesSet;\n\n  elem.setAttribute(\"data-id\", elemUniqueId);\n  elem.innerHTML = fragment.innerHTML;\n\n  const event = new CustomEvent(\"iconload\", {\n    bubbles: true,\n  });\n  elem.dispatchEvent(event);\n\n  if (elem.getAttribute(\"oniconload\")) {\n    // Handling (and executing) event attribute for our event (oniconload)\n    // isn't straightforward. Because a) the code is a raw string b) there's\n    // no way to specify the context for execution. So, `this` in the attribute\n    // will point to `window` instead of the element itself.\n    //\n    // Here we are recycling a rarely used GlobalEventHandler 'onloadedmetadata'\n    // and offloading the execution to the browser. This is a hack, but because\n    // the event doesn't bubble, it shouldn't affect anything else in the code.\n    elem.setAttribute(\"onloadedmetadata\", elem.getAttribute(\"oniconload\"));\n\n    const event = new CustomEvent(\"loadedmetadata\", {\n      bubbles: false,\n    });\n    elem.dispatchEvent(event);\n\n    elem.removeAttribute(\"onloadedmetadata\");\n  }\n};\n\nconst requestsInProgress = {};\nconst memoryCache = {};\n\nconst renderIcon = async (elem) => {\n  const src = elem.getAttribute(\"data-src\");\n  const cacheOpt = elem.getAttribute(\"data-cache\");\n\n  const enableJs = elem.getAttribute(\"data-js\") === \"enabled\";\n  const disableUniqueIds = elem.getAttribute(\"data-unique-ids\") === \"disabled\";\n  const disableCssScoping =\n    elem.getAttribute(\"data-css-scoping\") === \"disabled\";\n\n  const lsCache = await isCacheAvailable(src);\n  const isCachingEnabled = cacheOpt !== \"disabled\";\n\n  const renderBodyCb = renderBody.bind(self, elem, {\n    enableJs,\n    disableUniqueIds,\n    disableCssScoping,\n  });\n\n  // Memory cache optimizes same icon requested multiple\n  // times on the page\n  if (memoryCache[src] || (isCachingEnabled && lsCache)) {\n    const cache = memoryCache[src] || lsCache;\n\n    renderBodyCb(cache);\n  } else {\n    // If the same icon is being requested to rendered\n    // avoid firing multiple XHRs\n    if (requestsInProgress[src]) {\n      setTimeout(() => renderIcon(elem), 20);\n      return;\n    }\n\n    requestsInProgress[src] = true;\n\n    fetch(src)\n      .then((response) => {\n        if (!response.ok) {\n          throw Error(\n            `Request for '${src}' returned ${response.status} (${response.statusText})`\n          );\n        }\n        return response.text();\n      })\n      .then((body) => {\n        const bodyLower = body.toLowerCase().trim();\n\n        if (!(bodyLower.startsWith(\"<svg\") || bodyLower.startsWith(\"<?xml\"))) {\n          throw Error(`Resource '${src}' returned an invalid SVG file`);\n        }\n\n        if (isCachingEnabled) {\n          setCache(src, body, cacheOpt);\n        }\n\n        memoryCache[src] = body;\n\n        renderBodyCb(body);\n      })\n      .catch((e) => {\n        console.error(e);\n      })\n      .finally(() => {\n        delete requestsInProgress[src];\n      });\n  }\n};\n\nlet intObserver;\nif (globalThis.IntersectionObserver) {\n  intObserver = new IntersectionObserver(\n    (entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          renderIcon(entry.target);\n\n          // Unobserve as soon as soon the icon is rendered\n          intObserver.unobserve(entry.target);\n        }\n      });\n    },\n    {\n      // Keep high root margin because intersection observer\n      // can be slow to react\n      rootMargin: \"1200px\",\n    }\n  );\n}\n\nconst handled = [];\nfunction renderAllSVGs() {\n  Array.from(document.querySelectorAll(\"svg[data-src]:not([data-id])\")).forEach(\n    (element) => {\n      if (handled.indexOf(element) !== -1) {\n        return;\n      }\n\n      handled.push(element);\n      if (element.getAttribute(\"data-loading\") === \"lazy\") {\n        intObserver.observe(element);\n      } else {\n        renderIcon(element);\n      }\n    }\n  );\n}\n\nlet observerAdded = false;\nconst addObservers = () => {\n  if (observerAdded) {\n    return;\n  }\n\n  observerAdded = true;\n  const observer = new MutationObserver((mutationRecords) => {\n    const shouldTriggerRender = mutationRecords.some((record) =>\n      Array.from(record.addedNodes).some(\n        (elem) =>\n          elem.nodeType === Node.ELEMENT_NODE &&\n          ((elem.getAttribute(\"data-src\") && !elem.getAttribute(\"data-id\")) || // Check if the element needs to be rendered\n            elem.querySelector(\"svg[data-src]:not([data-id])\")) // Check if any of the element's children need to be rendered\n      )\n    );\n\n    // If any node is added, render all new nodes because the nodes that have already\n    // been rendered won't be rendered again.\n    if (shouldTriggerRender) {\n      renderAllSVGs();\n    }\n\n    // If data-src is changed, re-render\n    mutationRecords.forEach((record) => {\n      if (record.type === \"attributes\") {\n        renderIcon(record.target);\n      }\n    });\n  });\n\n  observer.observe(document.documentElement, {\n    attributeFilter: [\"data-src\"],\n    attributes: true,\n    childList: true,\n    subtree: true,\n  });\n};\n\nif (globalThis.addEventListener) {\n  // Start rendering SVGs as soon as possible\n  const intervalCheck = setInterval(() => {\n    renderAllSVGs();\n  }, 100);\n\n  globalThis.addEventListener(\"DOMContentLoaded\", () => {\n    clearInterval(intervalCheck);\n\n    renderAllSVGs();\n    addObservers();\n  });\n}\n"],"names":["counter","module","exports","incr","decr","curr","idMap","attributeValueOrCSS","attributeName","svgRefRegex","urlRefRegex","match","replace","g0","g1","includes","css","prefix","re","RegExp","g2","localStorage","indexedDB","mockStorage","getStorage","async","name","hasStorage","getAvailableStorage","db","getObjectStore","mode","navigator","userAgentData","test","userAgent","databases","Promise","resolve","intervalId","tryIdb","finally","setInterval","clearInterval","idbReady","createStore","e","console","log","openDBConnection","transaction","objectStore","reject","request","window","open","onupgradeneeded","result","createObjectStore","onsuccess","onerror","error","method","value","key","get","JSON","parse","getItem","set","setItem","stringify","del","removeItem","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","cssScope","cssUrlFixer","STORAGE_NAME","DOM_EVENTS","attributesSet","renderBody","elem","options","body","enableJs","disableUniqueIds","disableCssScoping","doc","DOMParser","parseFromString","fragment","querySelector","eventNames","length","prop","document","head","startsWith","push","getAllEventNames","elemAttributesSet","getAttribute","Set","elemUniqueId","Array","from","querySelectorAll","forEach","id","newId","setAttribute","tagName","remove","scriptEl","createElement","innerHTML","appendChild","i","attributes","newValue","toLowerCase","removeAttribute","has","add","event","CustomEvent","bubbles","dispatchEvent","requestsInProgress","memoryCache","renderIcon","src","cacheOpt","lsCache","url","storage","item","Date","now","expiry","data","isCacheAvailable","isCachingEnabled","renderBodyCb","bind","self","cache","setTimeout","fetch","then","response","ok","Error","status","statusText","text","bodyLower","trim","cacheExp","parseInt","Number","isNaN","setCache","catch","intObserver","globalThis","IntersectionObserver","entries","entry","isIntersecting","target","unobserve","rootMargin","handled","renderAllSVGs","element","indexOf","observe","observerAdded","addEventListener","intervalCheck","MutationObserver","mutationRecords","some","record","addedNodes","nodeType","Node","ELEMENT_NODE","type","documentElement","attributeFilter","childList","subtree"],"sourceRoot":""}